import XCTest
@testable import Interspace

// MARK: - MPC Integration Tests
// These tests verify the end-to-end MPC wallet functionality

final class MPCIntegrationTests: XCTestCase {
    
    // Test configuration
    private let testTimeout: TimeInterval = 30.0
    private var testProfileId: String!
    private var mpcService: MPCWalletServiceHTTP!
    
    override func setUp() async throws {
        try await super.setUp()
        
        // Initialize test profile ID
        testProfileId = "test-profile-\(UUID().uuidString)"
        
        // Initialize MPC service
        mpcService = MPCWalletServiceHTTP.shared
        
        // Configure test environment
        #if DEBUG
        UserDefaults.standard.set(true, forKey: "mpcWalletEnabled")
        UserDefaults.standard.set(true, forKey: "mpcUseHTTP")
        // Note: Backend URL configuration would need to be done through APIService
        #endif
    }
    
    override func tearDown() async throws {
        // Clean up test data
        testProfileId = nil
        mpcService = nil
        try await super.tearDown()
    }
    
    // MARK: - Test Cases
    
    /// Test 1: Get Cloud Public Key
    func testGetCloudPublicKey() async throws {
        // Act
        let response = try await ProfileAPI.shared.getCloudPublicKey(profileId: testProfileId)
        
        // Assert
        XCTAssertTrue(response.success)
        XCTAssertNotNil(response.data.cloudPublicKey)
        XCTAssertFalse(response.data.cloudPublicKey.isEmpty)
        
        print("✅ Cloud public key received: \(response.data.cloudPublicKey)")
    }
    
    /// Test 2: Generate MPC Wallet
    func testGenerateMPCWallet() async throws {
        // Create expectation for async operation
        let expectation = XCTestExpectation(description: "MPC wallet generation")
        
        // Act
        do {
            let walletInfo = try await mpcService.generateWallet(for: testProfileId)
            
            // Assert
            XCTAssertFalse(walletInfo.address.isEmpty)
            XCTAssertTrue(walletInfo.address.hasPrefix("0x"))
            XCTAssertEqual(walletInfo.address.count, 42) // Ethereum address length
            XCTAssertFalse(walletInfo.publicKey.isEmpty)
            
            print("✅ MPC wallet generated:")
            print("   Address: \(walletInfo.address)")
            print("   Public Key: \(walletInfo.publicKey)")
            
            expectation.fulfill()
        } catch {
            XCTFail("Wallet generation failed: \(error)")
        }
        
        await fulfillment(of: [expectation], timeout: testTimeout)
    }
    
    /// Test 3: Check Wallet Status
    func testCheckWalletStatus() async throws {
        // First generate a wallet
        let walletInfo = try await mpcService.generateWallet(for: testProfileId)
        
        // Check if wallet exists
        let hasWallet = await mpcService.hasWallet(for: testProfileId)
        XCTAssertTrue(hasWallet)
        
        // Get wallet info
        let retrievedInfo = await mpcService.getWalletInfo(for: testProfileId)
        XCTAssertNotNil(retrievedInfo)
        XCTAssertEqual(retrievedInfo?.address, walletInfo.address)
    }
    
    /// Test 4: Sign Transaction
    func testSignTransaction() async throws {
        // Skip if wallet doesn't exist
        guard await mpcService.hasWallet(for: testProfileId) else {
            try await testGenerateMPCWallet()
            return
        }
        
        // Create test transaction hash
        let testMessage = "Test transaction data"
        let messageData = testMessage.data(using: .utf8)!
        
        // Create test transaction
        let transaction = TransactionRequest(
            hash: messageData,
            chainPath: nil,
            value: "0x0",
            to: "0x742d35Cc6634C0532925a3b844Bc9e7595f8150",
            data: "0x"
        )
        
        // Act
        do {
            let signature = try await mpcService.signTransaction(
                profileId: testProfileId,
                transaction: transaction
            )
            
            // Assert
            XCTAssertFalse(signature.isEmpty)
            XCTAssertTrue(signature.hasPrefix("0x"))
            
            print("✅ Transaction signed:")
            print("   Signature: \(signature)")
            
        } catch {
            XCTFail("Transaction signing failed: \(error)")
        }
    }
    
    /// Test 5: Session Status Polling
    func testSessionStatusPolling() async throws {
        // Start key generation
        let p1Messages: [[String: Any]] = [] // Would be generated by SDK
        let response = try await ProfileAPI.shared.startKeyGeneration(
            profileId: testProfileId,
            p1Messages: p1Messages
        )
        
        XCTAssertTrue(response.success)
        let sessionId = response.data.sessionId
        
        // Poll for status
        var attempts = 0
        let maxAttempts = 10
        
        while attempts < maxAttempts {
            let statusResponse = try await ProfileAPI.shared.getSessionStatus(sessionId: sessionId)
            
            print("Session status: \(statusResponse.data.status)")
            
            if statusResponse.data.status == "completed" {
                XCTAssertNotNil(statusResponse.data.result?.keyId)
                XCTAssertNotNil(statusResponse.data.result?.address)
                break
            } else if statusResponse.data.status == "failed" {
                XCTFail("Session failed: \(statusResponse.data.error ?? "Unknown error")")
                break
            }
            
            // Wait before next poll
            try await Task.sleep(nanoseconds: 1_000_000_000) // 1 second
            attempts += 1
        }
        
        XCTAssertLessThan(attempts, maxAttempts, "Session did not complete in time")
    }
    
    /// Test 6: Error Handling
    func testErrorHandling() async throws {
        // Test with invalid profile ID
        do {
            _ = try await mpcService.generateWallet(for: "invalid-profile-id")
            XCTFail("Should have thrown an error")
        } catch {
            // Expected error
            print("✅ Error correctly caught: \(error)")
        }
        
        // Test signing without wallet
        let nonExistentProfile = "non-existent-\(UUID().uuidString)"
        do {
            let testData = "Test data".data(using: .utf8)!
            let transaction = TransactionRequest(
                hash: testData,
                chainPath: nil,
                value: "0x0",
                to: "0x742d35Cc6634C0532925a3b844Bc9e7595f8150",
                data: "0x"
            )
            _ = try await mpcService.signTransaction(
                profileId: nonExistentProfile,
                transaction: transaction
            )
            XCTFail("Should have thrown keyShareNotFound error")
        } catch MPCError.keyShareNotFound {
            print("✅ Correctly caught keyShareNotFound error")
        } catch {
            XCTFail("Unexpected error type: \(error)")
        }
    }
    
    /// Test 7: Concurrent Operations
    func testConcurrentOperations() async throws {
        // Try to generate multiple wallets concurrently
        let profile1 = "concurrent-1-\(UUID().uuidString)"
        let profile2 = "concurrent-2-\(UUID().uuidString)"
        
        async let wallet1 = mpcService.generateWallet(for: profile1)
        async let wallet2 = mpcService.generateWallet(for: profile2)
        
        do {
            let (result1, result2) = try await (wallet1, wallet2)
            
            // Both should succeed with different addresses
            XCTAssertNotEqual(result1.address, result2.address)
            print("✅ Concurrent wallet generation successful")
            print("   Wallet 1: \(result1.address)")
            print("   Wallet 2: \(result2.address)")
            
        } catch MPCError.operationInProgress {
            // This is expected if the service doesn't support concurrent operations
            print("⚠️ Concurrent operations not supported (as expected)")
        }
    }
}

// MARK: - Performance Tests

extension MPCIntegrationTests {
    
    /// Measure wallet generation performance
    func testWalletGenerationPerformance() {
        self.measure {
            let expectation = XCTestExpectation(description: "Performance test")
            
            Task {
                do {
                    let profileId = "perf-test-\(UUID().uuidString)"
                    _ = try await mpcService.generateWallet(for: profileId)
                    expectation.fulfill()
                } catch {
                    XCTFail("Performance test failed: \(error)")
                }
            }
            
            wait(for: [expectation], timeout: testTimeout)
        }
    }
}

// MARK: - Mock Data for Testing

// TransactionRequest is imported from the main app target

// MARK: - Test Helpers

// ProfileAPI configuration is handled through MPCConfiguration