diff --git a/Interspace/Models/AuthModels.swift b/Interspace/Models/AuthModels.swift
index e90f6b3..bc6f1e4 100644
--- a/Interspace/Models/AuthModels.swift
+++ b/Interspace/Models/AuthModels.swift
@@ -1,6 +1,7 @@
 import Foundation
 import UIKit
 import SwiftUI
+import AuthenticationServices
 
 // MARK: - Authentication Strategy
 enum AuthStrategy: String, CaseIterable, Codable {
@@ -172,6 +173,11 @@ enum AuthenticationError: LocalizedError, Identifiable {
     case emailVerificationFailed
     case tokenExpired
     case unknown(String)
+    case passkeyNotSupported
+    case passkeyAuthenticationFailed(String)
+    case passkeyRegistrationFailed(String)
+    case notAuthenticated
+    case emailRequired
     
     var id: String {
         switch self {
@@ -187,6 +193,16 @@ enum AuthenticationError: LocalizedError, Identifiable {
             return "tokenExpired"
         case .unknown(let message):
             return "unknown-\(message)"
+        case .passkeyNotSupported:
+            return "passkeyNotSupported"
+        case .passkeyAuthenticationFailed(let message):
+            return "passkeyAuthenticationFailed-\(message)"
+        case .passkeyRegistrationFailed(let message):
+            return "passkeyRegistrationFailed-\(message)"
+        case .notAuthenticated:
+            return "notAuthenticated"
+        case .emailRequired:
+            return "emailRequired"
         }
     }
     
@@ -204,6 +220,16 @@ enum AuthenticationError: LocalizedError, Identifiable {
             return "Your session has expired. Please sign in again."
         case .unknown(let message):
             return message
+        case .passkeyNotSupported:
+            return "Passkeys are only supported on iOS 16 and later."
+        case .passkeyAuthenticationFailed(let message):
+            return "Passkey authentication failed: \(message)"
+        case .passkeyRegistrationFailed(let message):
+            return "Passkey registration failed: \(message)"
+        case .notAuthenticated:
+            return "You must be signed in to perform this action."
+        case .emailRequired:
+            return "Email address is required for passkey registration."
         }
     }
 }
@@ -226,4 +252,30 @@ struct DeviceInfo {
     }
     
     static let deviceType = "ios"
+}
+
+// MARK: - Apple Sign-In Models
+struct AppleSignInResult {
+    let userId: String
+    let identityToken: String
+    let authorizationCode: String
+    let email: String?
+    let fullName: PersonNameComponents?
+    let realUserStatus: ASUserDetectionStatus
+}
+
+struct AppleAuthRequest: Codable {
+    let identityToken: String
+    let authorizationCode: String
+    let user: AppleUserInfo
+    let deviceId: String
+    let deviceName: String
+    let deviceType: String
+}
+
+struct AppleUserInfo: Codable {
+    let id: String
+    let email: String?
+    let firstName: String?
+    let lastName: String?
 }
\ No newline at end of file
diff --git a/Interspace/Services/AuthService.swift b/Interspace/Services/AuthService.swift
index 7dbfb9f..621040c 100644
--- a/Interspace/Services/AuthService.swift
+++ b/Interspace/Services/AuthService.swift
@@ -437,16 +437,13 @@ final class PasskeyService {
             body = try? JSONEncoder().encode(requestData)
         }
         
-        let result: Result<PasskeyOptionsResponse, APIError> = await withCheckedContinuation { continuation in
-            APIService.shared.request(
-                endpoint: endpoint,
-                method: "POST",
-                body: body,
-                requiresAuth: isRegistration
-            ) { result in
-                continuation.resume(returning: result)
-            }
-        }
+        let result = try await APIService.shared.performRequest(
+            endpoint: endpoint,
+            method: .POST,
+            body: body,
+            responseType: PasskeyOptionsResponse.self,
+            requiresAuth: isRegistration
+        )
         
         switch result {
         case .success(let response):
@@ -515,7 +512,7 @@ final class PasskeyService {
                 )
             ),
             challenge: challenge,
-            deviceName: deviceName ?? UIDevice.current.name
+            deviceName: deviceName ?? (await MainActor.run { UIDevice.current.name })
         )
         
         let verifyResult: Result<PasskeyVerifyResponse, APIError> = await withCheckedContinuation { continuation in
@@ -553,22 +550,22 @@ final class PasskeyService {
         let (challenge, optionsData) = try await getPasskeyChallenge(for: username, isRegistration: false)
         
         guard let options = try? JSONDecoder().decode(PasskeyOptions.self, from: optionsData),
-              let rpId = options.rp?.id ?? PasskeyService.getDefaultRPID(),
               let challengeData = Data(base64URLEncoded: challenge) else {
             throw PasskeyError.authenticationFailed
         }
         
+        let rpId = options.rp?.id ?? PasskeyService.getDefaultRPID()
+        
         let platformProvider = ASAuthorizationPlatformPublicKeyCredentialProvider(relyingPartyIdentifier: rpId)
         
         let assertionRequest = platformProvider.createCredentialAssertionRequest(challenge: challengeData)
         
         // If we have allowed credentials from server, set them
         if let allowedCredentials = options.allowCredentials, !allowedCredentials.isEmpty {
-            assertionRequest.allowedCredentials = allowedCredentials.compactMap { cred in
+            assertionRequest.allowedCredentials = allowedCredentials.compactMap { cred -> ASAuthorizationPlatformPublicKeyCredentialDescriptor? in
                 guard let credIdData = Data(base64URLEncoded: cred.id) else { return nil }
-                return ASAuthorizationPlatformPublicKeyCredentialAssertionRequest.Credential(
-                    credentialID: credIdData,
-                    transports: []
+                return ASAuthorizationPlatformPublicKeyCredentialDescriptor(
+                    credentialID: credIdData
                 )
             }
         }
@@ -607,7 +604,7 @@ final class PasskeyService {
                 )
             ),
             challenge: challenge,
-            deviceName: UIDevice.current.name
+            deviceName: await MainActor.run { UIDevice.current.name }
         )
         
         let verifyResult: Result<PasskeyVerifyResponse, APIError> = await withCheckedContinuation { continuation in
@@ -616,9 +613,8 @@ final class PasskeyService {
                 APIService.shared.request(
                     endpoint: "/auth/passkey/authenticate-verify",
                     method: "POST",
-                    body: body,
-                    requiresAuth: false
-                ) { result in
+                    body: body
+                ) { (result: Result<PasskeyVerifyResponse, APIError>) in
                     continuation.resume(returning: result)
                 }
             } catch {
@@ -755,3 +751,183 @@ extension Data {
         self.init(base64Encoded: base64)
     }
 }
+
+// MARK: - AppleSignInService
+
+final class AppleSignInService: NSObject {
+    static let shared = AppleSignInService()
+    
+    private var signInContinuation: CheckedContinuation<AppleSignInResult, Error>?
+    
+    override private init() {
+        super.init()
+    }
+    
+    @MainActor
+    func signIn() async throws -> AppleSignInResult {
+        print("üçé AppleSignInService: Starting Apple Sign-In flow")
+        
+        let appleIDProvider = ASAuthorizationAppleIDProvider()
+        let request = appleIDProvider.createRequest()
+        request.requestedScopes = [.fullName, .email]
+        
+        let authorizationController = ASAuthorizationController(authorizationRequests: [request])
+        authorizationController.delegate = self
+        authorizationController.presentationContextProvider = self
+        
+        return try await withCheckedThrowingContinuation { continuation in
+            self.signInContinuation = continuation
+            authorizationController.performRequests()
+        }
+    }
+    
+    func checkCredentialState(userID: String) async throws -> ASAuthorizationAppleIDProvider.CredentialState {
+        let appleIDProvider = ASAuthorizationAppleIDProvider()
+        return try await withCheckedThrowingContinuation { continuation in
+            appleIDProvider.getCredentialState(forUserID: userID) { credentialState, error in
+                if let error = error {
+                    continuation.resume(throwing: error)
+                } else {
+                    continuation.resume(returning: credentialState)
+                }
+            }
+        }
+    }
+}
+
+// MARK: - ASAuthorizationControllerDelegate
+
+extension AppleSignInService: ASAuthorizationControllerDelegate {
+    func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {
+        print("üçé AppleSignInService: Authorization completed successfully")
+        
+        guard let appleIDCredential = authorization.credential as? ASAuthorizationAppleIDCredential else {
+            print("üçé AppleSignInService: ERROR - Invalid credential type")
+            signInContinuation?.resume(throwing: AppleSignInError.invalidCredential)
+            signInContinuation = nil
+            return
+        }
+        
+        // Extract identity token
+        guard let identityTokenData = appleIDCredential.identityToken,
+              let identityToken = String(data: identityTokenData, encoding: .utf8) else {
+            print("üçé AppleSignInService: ERROR - No identity token")
+            signInContinuation?.resume(throwing: AppleSignInError.noIdentityToken)
+            signInContinuation = nil
+            return
+        }
+        
+        // Extract authorization code
+        guard let authorizationCodeData = appleIDCredential.authorizationCode,
+              let authorizationCode = String(data: authorizationCodeData, encoding: .utf8) else {
+            print("üçé AppleSignInService: ERROR - No authorization code")
+            signInContinuation?.resume(throwing: AppleSignInError.noAuthorizationCode)
+            signInContinuation = nil
+            return
+        }
+        
+        print("üçé AppleSignInService: Successfully extracted tokens")
+        print("üçé AppleSignInService: User ID: \(appleIDCredential.user)")
+        print("üçé AppleSignInService: Email: \(appleIDCredential.email ?? "Not provided")")
+        print("üçé AppleSignInService: Full Name: \(appleIDCredential.fullName?.formatted() ?? "Not provided")")
+        print("üçé AppleSignInService: Real User Status: \(appleIDCredential.realUserStatus.rawValue)")
+        
+        let result = AppleSignInResult(
+            userId: appleIDCredential.user,
+            identityToken: identityToken,
+            authorizationCode: authorizationCode,
+            email: appleIDCredential.email,
+            fullName: appleIDCredential.fullName,
+            realUserStatus: appleIDCredential.realUserStatus
+        )
+        
+        signInContinuation?.resume(returning: result)
+        signInContinuation = nil
+    }
+    
+    func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: Error) {
+        print("üçé AppleSignInService: Authorization failed with error: \(error)")
+        
+        if let authError = error as? ASAuthorizationError {
+            switch authError.code {
+            case .canceled:
+                print("üçé AppleSignInService: User cancelled sign-in")
+                signInContinuation?.resume(throwing: AppleSignInError.userCancelled)
+            case .failed:
+                print("üçé AppleSignInService: Authorization failed")
+                signInContinuation?.resume(throwing: AppleSignInError.authorizationFailed)
+            case .invalidResponse:
+                print("üçé AppleSignInService: Invalid response")
+                signInContinuation?.resume(throwing: AppleSignInError.invalidResponse)
+            case .notHandled:
+                print("üçé AppleSignInService: Authorization not handled")
+                signInContinuation?.resume(throwing: AppleSignInError.notHandled)
+            case .unknown:
+                print("üçé AppleSignInService: Unknown error")
+                signInContinuation?.resume(throwing: AppleSignInError.unknown)
+            case .notInteractive:
+                print("üçé AppleSignInService: Not interactive")
+                signInContinuation?.resume(throwing: AppleSignInError.notHandled)
+            case .matchedExcludedCredential:
+                print("üçé AppleSignInService: Matched excluded credential")
+                signInContinuation?.resume(throwing: AppleSignInError.invalidCredential)
+            default:
+                print("üçé AppleSignInService: Other error: \(authError)")
+                signInContinuation?.resume(throwing: error)
+            }
+        } else {
+            signInContinuation?.resume(throwing: error)
+        }
+        
+        signInContinuation = nil
+    }
+}
+
+// MARK: - ASAuthorizationControllerPresentationContextProviding
+
+extension AppleSignInService: ASAuthorizationControllerPresentationContextProviding {
+    func presentationAnchor(for controller: ASAuthorizationController) -> ASPresentationAnchor {
+        guard let scene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
+              let window = scene.windows.first(where: { $0.isKeyWindow }) ?? scene.windows.first else {
+            print("üçé AppleSignInService: WARNING - No key window found, using new window")
+            return UIWindow()
+        }
+        
+        print("üçé AppleSignInService: Using window: \(window)")
+        return window
+    }
+}
+
+// MARK: - AppleSignInError
+
+enum AppleSignInError: LocalizedError {
+    case invalidCredential
+    case noIdentityToken
+    case noAuthorizationCode
+    case userCancelled
+    case authorizationFailed
+    case invalidResponse
+    case notHandled
+    case unknown
+    
+    var errorDescription: String? {
+        switch self {
+        case .invalidCredential:
+            return "Invalid Apple ID credential"
+        case .noIdentityToken:
+            return "No identity token received from Apple"
+        case .noAuthorizationCode:
+            return "No authorization code received from Apple"
+        case .userCancelled:
+            return "Sign in with Apple was cancelled"
+        case .authorizationFailed:
+            return "Apple authorization failed"
+        case .invalidResponse:
+            return "Invalid response from Apple"
+        case .notHandled:
+            return "Apple authorization was not handled"
+        case .unknown:
+            return "Unknown error occurred during Apple Sign-In"
+        }
+    }
+}
diff --git a/Interspace/Services/AuthenticationManager.swift b/Interspace/Services/AuthenticationManager.swift
index beef985..6ea678a 100644
--- a/Interspace/Services/AuthenticationManager.swift
+++ b/Interspace/Services/AuthenticationManager.swift
@@ -377,30 +377,148 @@ final class AuthenticationManager: ObservableObject {
         }
     }
     
+    @available(iOS 16.0, *)
     func authenticateWithPasskey(email: String? = nil) async throws {
-        let passkeyResult: PasskeyResult
+        guard PasskeyService.isPasskeyAvailable() else {
+            throw AuthenticationError.passkeyNotSupported
+        }
         
-        if let email = email {
-            // Registration flow
-            passkeyResult = try await PasskeyService.shared.registerPasskey(for: email)
-        } else {
-            // Authentication flow
-            passkeyResult = try await PasskeyService.shared.authenticateWithPasskey()
+        DispatchQueue.main.async {
+            self.isLoading = true
+            self.error = nil
         }
         
-        let config = WalletConnectionConfig(
-            strategy: .passkey,
-            walletType: nil,
-            email: nil,
-            verificationCode: passkeyResult.credentialID,
-            walletAddress: nil,
-            signature: passkeyResult.signature,
-            message: nil,
-            socialProvider: nil,
-            socialProfile: nil
+        do {
+            // Authentication flow - returns tokens directly
+            let tokens = try await PasskeyService.shared.authenticateWithPasskey(username: email)
+            
+            // Store tokens
+            KeychainManager.shared.accessToken = tokens.accessToken
+            KeychainManager.shared.refreshToken = tokens.refreshToken
+            
+            // Update authentication state
+            DispatchQueue.main.async {
+                self.isAuthenticated = true
+                self.isLoading = false
+            }
+            
+            // Fetch user profile
+            await fetchCurrentUser()
+            
+        } catch {
+            DispatchQueue.main.async {
+                self.isLoading = false
+                self.error = AuthenticationError.passkeyAuthenticationFailed(error.localizedDescription)
+            }
+            throw error
+        }
+    }
+    
+    func authenticateWithApple() async throws {
+        print("üçé AuthenticationManager: Starting Apple authentication")
+        
+        await MainActor.run {
+            isLoading = true
+            error = nil
+        }
+        
+        #if DEBUG
+        // Check if development mode is enabled
+        if EnvironmentConfiguration.shared.isDevelopmentModeEnabled {
+            print("üçé AuthenticationManager: Using development mode Apple Sign-In")
+            
+            // Create mock Apple result
+            let mockResult = AppleSignInResult(
+                userId: "dev_apple_user_\(UUID().uuidString)",
+                identityToken: "dev_apple_identity_token_\(UUID().uuidString)",
+                authorizationCode: "dev_apple_auth_code_\(UUID().uuidString)",
+                email: "dev.apple@example.com",
+                fullName: PersonNameComponents(
+                    givenName: "Dev",
+                    familyName: "Apple"
+                ),
+                realUserStatus: .likelyReal
+            )
+            
+            try await handleAppleSignInResult(mockResult)
+            return
+        }
+        #endif
+        
+        do {
+            let appleResult = try await AppleSignInService.shared.signIn()
+            print("üçé AuthenticationManager: Apple Sign-In successful, user: \(appleResult.userId)")
+            
+            try await handleAppleSignInResult(appleResult)
+            
+        } catch let error as AppleSignInError {
+            // Map Apple Sign-In errors to authentication errors
+            await MainActor.run {
+                isLoading = false
+            }
+            
+            switch error {
+            case .userCancelled:
+                // User cancelled - don't show error
+                print("üçé AuthenticationManager: User cancelled Apple Sign-In")
+                throw AuthenticationError.unknown("")
+            case .noIdentityToken, .noAuthorizationCode:
+                throw AuthenticationError.unknown("Apple Sign-In failed: Missing required tokens")
+            case .invalidCredential, .authorizationFailed, .invalidResponse:
+                throw AuthenticationError.unknown("Apple Sign-In authorization failed")
+            default:
+                throw AuthenticationError.unknown(error.localizedDescription)
+            }
+        } catch {
+            await MainActor.run {
+                isLoading = false
+            }
+            throw error
+        }
+    }
+    
+    private func handleAppleSignInResult(_ result: AppleSignInResult) async throws {
+        print("üçé AuthenticationManager: Processing Apple Sign-In result")
+        
+        // Build Apple auth request
+        let appleAuthRequest = AppleAuthRequest(
+            identityToken: result.identityToken,
+            authorizationCode: result.authorizationCode,
+            user: AppleUserInfo(
+                id: result.userId,
+                email: result.email,
+                firstName: result.fullName?.givenName,
+                lastName: result.fullName?.familyName
+            ),
+            deviceId: DeviceInfo.deviceId,
+            deviceName: DeviceInfo.deviceName,
+            deviceType: DeviceInfo.deviceType
         )
         
-        try await authenticate(with: config)
+        // Authenticate with backend
+        let response = try await authAPI.authenticateWithApple(request: appleAuthRequest)
+        
+        print("üçé AuthenticationManager: Apple authentication API call successful!")
+        
+        // Save tokens securely
+        try keychainManager.saveTokens(
+            access: response.data.accessToken,
+            refresh: response.data.refreshToken,
+            expiresIn: response.data.expiresIn
+        )
+        
+        // Set token in API service
+        APIService.shared.setAccessToken(response.data.accessToken)
+        
+        // Fetch user info
+        await fetchCurrentUser()
+        
+        await MainActor.run {
+            self.isAuthenticated = true
+            self.isLoading = false
+        }
+        
+        print("üçé AuthenticationManager: Apple authentication completed successfully!")
     }
     
     // MARK: - Wallet Profile Management
diff --git a/Interspace/ViewModels/AuthViewModel.swift b/Interspace/ViewModels/AuthViewModel.swift
index 04597ca..1bdbdaa 100644
--- a/Interspace/ViewModels/AuthViewModel.swift
+++ b/Interspace/ViewModels/AuthViewModel.swift
@@ -82,6 +82,13 @@ final class AuthViewModel: ObservableObject {
             break // Show email input
         case .guest:
             authenticateAsGuest()
+        case .passkey:
+            if #available(iOS 16.0, *) {
+                authenticateWithPasskey()
+            } else {
+                error = AuthenticationError.passkeyNotSupported
+                showError = true
+            }
         default:
             break
         }
@@ -197,6 +204,76 @@ final class AuthViewModel: ObservableObject {
         return emailPredicate.evaluate(with: email)
     }
     
+    // MARK: - Passkey Authentication
+    
+    @available(iOS 16.0, *)
+    func authenticateWithPasskey() {
+        Task {
+            do {
+                isLoading = true
+                error = nil
+                
+                let tokens = try await PasskeyService.shared.authenticateWithPasskey()
+                
+                // Store tokens in keychain
+                if !tokens.accessToken.isEmpty {
+                    KeychainManager.shared.accessToken = tokens.accessToken
+                    KeychainManager.shared.refreshToken = tokens.refreshToken
+                    
+                    // Update authentication state
+                    await MainActor.run {
+                        authManager.isAuthenticated = true
+                    }
+                }
+                
+                isLoading = false
+            } catch {
+                await MainActor.run {
+                    self.isLoading = false
+                    self.error = AuthenticationError.passkeyAuthenticationFailed(error.localizedDescription)
+                    self.showError = true
+                }
+            }
+        }
+    }
+    
+    @available(iOS 16.0, *)
+    func registerPasskey() {
+        guard authManager.isAuthenticated else {
+            error = AuthenticationError.notAuthenticated
+            showError = true
+            return
+        }
+        
+        Task {
+            do {
+                isLoading = true
+                error = nil
+                
+                // Get current user email
+                let userEmail = authManager.currentUser?.email ?? email
+                guard !userEmail.isEmpty else {
+                    throw AuthenticationError.emailRequired
+                }
+                
+                let _ = try await PasskeyService.shared.registerPasskey(for: userEmail)
+                
+                await MainActor.run {
+                    self.isLoading = false
+                    // Show success message
+                    self.errorMessage = "Passkey registered successfully!"
+                    self.showError = true
+                }
+            } catch {
+                await MainActor.run {
+                    self.isLoading = false
+                    self.error = AuthenticationError.passkeyRegistrationFailed(error.localizedDescription)
+                    self.showError = true
+                }
+            }
+        }
+    }
+    
     // MARK: - Wallet Authentication
     
     func selectWallet(_ walletType: WalletType) {
diff --git a/Interspace/Views/AuthView.swift b/Interspace/Views/AuthView.swift
index 600bf37..00a64a6 100644
--- a/Interspace/Views/AuthView.swift
+++ b/Interspace/Views/AuthView.swift
@@ -33,6 +33,7 @@ struct AuthView: View {
                             onConnectCoinbase: connectCoinbaseWallet,
                             onConnectWalletConnect: connectWalletConnect,
                             onAuthenticateGoogle: authenticateWithGoogle,
+                            onAuthenticateApple: authenticateWithApple,
                             onAuthenticatePasskey: authenticateWithPasskey,
                             onAuthenticateGuest: authenticateAsGuest,
                             onShowEmailAuth: showEmailAuthentication,
@@ -162,10 +163,29 @@ struct AuthView: View {
     }
     
     private func authenticateWithPasskey() async {
+        if #available(iOS 16.0, *) {
+            do {
+                try await authManager.authenticateWithPasskey()
+            } catch {
+                print("üîó AuthView: Passkey authentication error: \(error)")
+            }
+        } else {
+            // This shouldn't happen since button is hidden on iOS < 16
+            print("üîó AuthView: Passkeys not supported on this iOS version")
+        }
+    }
+    
+    private func authenticateWithApple() async {
+        print("üîó AuthView: User tapped Apple Sign-In button")
         do {
-            try await authManager.authenticateWithPasskey()
+            try await authManager.authenticateWithApple()
+            print("üîó AuthView: Apple authentication completed successfully")
         } catch {
-            print("üîó AuthView: Passkey authentication error: \(error)")
+            print("üîó AuthView: Apple authentication error: \(error)")
+            // Don't show error alert for user cancellation (empty error message)
+            if error.localizedDescription.isEmpty {
+                print("üîó AuthView: User cancelled Apple Sign-In")
+            }
         }
     }
     
@@ -273,6 +293,7 @@ struct UnauthenticatedView: View {
     let onConnectCoinbase: () async -> Void
     let onConnectWalletConnect: () async -> Void
     let onAuthenticateGoogle: () async -> Void
+    let onAuthenticateApple: () async -> Void
     let onAuthenticatePasskey: () async -> Void
     let onAuthenticateGuest: () async -> Void
     let onShowEmailAuth: () -> Void
@@ -423,14 +444,16 @@ struct UnauthenticatedView: View {
                             onShowEmailAuth()
                         }
                         
-                        LiquidGlassAuthButton(
-                            title: "Sign in with Passkey",
-                            subtitle: "Use Face ID or Touch ID",
-                            icon: "faceid",
-                            walletType: .apple
-                        ) {
-                            Task {
-                                await onAuthenticatePasskey()
+                        if #available(iOS 16.0, *), PasskeyService.isPasskeyAvailable() {
+                            LiquidGlassAuthButton(
+                                title: "Sign in with Passkey",
+                                subtitle: "Use Face ID or Touch ID",
+                                icon: "faceid",
+                                walletType: .apple
+                            ) {
+                                Task {
+                                    await onAuthenticatePasskey()
+                                }
                             }
                         }
                     }
